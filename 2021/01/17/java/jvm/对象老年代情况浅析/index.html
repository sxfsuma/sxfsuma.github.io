<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>对象进入老年代情况浅析 | sxfsuma</title><meta name="keywords" content="Jvm"><meta name="author" content="mastersxf"><meta name="copyright" content="mastersxf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="最近在做项目性能优化的时候，其中有一点是需要优化老年代GC的情况，一是需要尽量避免老年代的增长，尽可能不发生Full GC或者是极大延长Full GC的时间间隔，二是降低Full GC期间的STW时间，需要考分析引起老年代增长的具体原因，本文整理一下对象进入老年代的几种情况，方便之后回顾。 对象进入老年代的情况主要分为以下四种：  1、长期存活的对象进入老年代。 2、大对象进入老年代。 3、空间分">
<meta property="og:type" content="article">
<meta property="og:title" content="对象进入老年代情况浅析">
<meta property="og:url" content="https://sxfsuma.github.io/2021/01/17/java/jvm/%E5%AF%B9%E8%B1%A1%E8%80%81%E5%B9%B4%E4%BB%A3%E6%83%85%E5%86%B5%E6%B5%85%E6%9E%90/index.html">
<meta property="og:site_name" content="sxfsuma">
<meta property="og:description" content="最近在做项目性能优化的时候，其中有一点是需要优化老年代GC的情况，一是需要尽量避免老年代的增长，尽可能不发生Full GC或者是极大延长Full GC的时间间隔，二是降低Full GC期间的STW时间，需要考分析引起老年代增长的具体原因，本文整理一下对象进入老年代的几种情况，方便之后回顾。 对象进入老年代的情况主要分为以下四种：  1、长期存活的对象进入老年代。 2、大对象进入老年代。 3、空间分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.JsDelivr.net/gh/sxfsuma/cloudImg//data/img路人女主-加藤惠.jpeg">
<meta property="article:published_time" content="2021-01-17T01:40:35.000Z">
<meta property="article:modified_time" content="2021-02-24T15:57:51.747Z">
<meta property="article:author" content="mastersxf">
<meta property="article:tag" content="Jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.JsDelivr.net/gh/sxfsuma/cloudImg//data/img路人女主-加藤惠.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sxfsuma.github.io/2021/01/17/java/jvm/%E5%AF%B9%E8%B1%A1%E8%80%81%E5%B9%B4%E4%BB%A3%E6%83%85%E5%86%B5%E6%B5%85%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-02-24 23:57:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://avatars3.githubusercontent.com/u/22931851?s=460&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.JsDelivr.net/gh/sxfsuma/cloudImg//data/img路人女主-加藤惠.jpeg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">sxfsuma</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">对象进入老年代情况浅析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-17T01:40:35.000Z" title="发表于 2021-01-17 09:40:35">2021-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-24T15:57:51.747Z" title="更新于 2021-02-24 23:57:51">2021-02-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>最近在做项目性能优化的时候，其中有一点是需要优化老年代GC的情况，一是需要尽量避免老年代的增长，尽可能不发生Full GC或者是极大延长Full GC的时间间隔，二是降低Full GC期间的STW时间，需要考分析引起老年代增长的具体原因，本文整理一下对象进入老年代的几种情况，方便之后回顾。</p>
<p>对象进入老年代的情况主要分为以下四种：</p>
<ul>
<li>1、长期存活的对象进入老年代。</li>
<li>2、大对象进入老年代。</li>
<li>3、空间分配担保机制。</li>
<li>4、动态年龄判定。</li>
</ul>
<p>下面来逐个简单总结一下。</p>
<h3 id="长期存活对象进入老年代。"><a href="#长期存活对象进入老年代。" class="headerlink" title="长期存活对象进入老年代。"></a>长期存活对象进入老年代。</h3><p>年轻代的对象每“熬过”一次Young  GC，对象的年龄计数器就会加1，当年龄达到进入老年代的年龄阈值的时候就可以进入老年代。</p>
<p>进入老年代的年龄阈值可以通过 <code>-XX:MaxTenuringThreshold </code>参数值来设置。对于这个参数，大家第一反应可能就是默认值是15，但是有以下几点需要注意：</p>
<p>1、进入老年代年龄阈值最大值是15，也就是<code>MaxTenuringThreshold</code>最大值为15。</p>
<p>2、默认值不总是15，比如在<code>CMS</code>垃圾回收器下默认是就是6，而不是15。</p>
<p>3、实际的阈值不是固定不变的，是动态变化的。 （这个在动态年龄判定中会详细说到）</p>
<p>下面解释一下第一点和第二点，关于第三点会在动态年龄判定中进行详细描述。</p>
<p>1、首先解释一下最大值只能到15的原因，如果了解对象的结构的话就会知道对象的分代年龄存储在对象的对象头的Mark Word 中，不管是在32位的JVM中还是64位的<code>JVM</code>中，年龄计数器都占比4个bit，意味着年龄计数器的最大值只能计到15（1111）。这也是为什么进入老年代的年龄阈值最大值为15的原因。</p>
<p>下面表示的是32位的JVM下对象头的Mark Word的结构:</p>
<table borderCollapse="collapse" border="1" solid=#555555>
  <tr align="center">
     <th colspan="6" bgcolor=#D2691E>Mark Word (32bit)</th>
  </tr>
  <tr align="center">
    <th rowspan="2" border="1" bgcolor=#E6E6FA>锁状态</th>
    <th colspan="2" bgcolor=#E6E6FA>25bit</th>
    <th rowspan="2" bgcolor=#E6E6FA>4bit</th>
    <th bgcolor=#E6E6FA>1bit</th>
    <th bgcolor=#E6E6FA>2bit</th>
  </tr>
  <tr align="center">
    <td bgcolor=#E6E6FA>23bit</td>
    <td bgcolor=#E6E6FA>2bit</td>
    <td bgcolor=#E6E6FA>是否偏向锁</td>
    <td bgcolor=#E6E6FA>锁标志位</td>
  </tr>
  <tr align="center">
    <td>无锁状态</td>
    <td colspan="2">对象的hash code</td>
    <td>分代年龄</td>
      <td>0</td>
      <td>01</td>
  </tr>
  <tr align="center">
    <td>轻量级锁</td>
    <td  colspan="4">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
    <tr align="center">
    <td>重量级锁</td>
    <td  colspan="4">指向互斥量(重量级锁)的指针</td>
    <td>10</td>
  </tr>
    <tr align="center">
    <td>GC标志</td>
    <td  colspan="4">unused</td>
    <td>11</td>
  </tr>
    <tr align="center">
    <td>偏向锁</td>
    <td>线程ID</td>
    <td>epoch</td>
    <td>分代年龄</td>
    <td>1</td>
    <td>01</td>
  </tr>
</table>

<p>64位JVM下对象头的Mark Word的结构:</p>
<table borderCollapse="collapse" border="1" solid=#555555>
  <tr align="center">
     <th colspan="10" bgcolor=#D2691E>Mark Word (64bit)</th>
  </tr>
  <tr align="center">
    <th rowspan="2" border="1" bgcolor=#E6E6FA>锁状态</th>
    <th colspan="2" bgcolor=#E6E6FA>25bit</th>
    <th colspan="3" bgcolor=#E6E6FA>31bit</th>
    <th bgcolor=#E6E6FA rowspan="2">1bit</th>
    <th bgcolor=#E6E6FA rowspan="2">4bit</th>
    <th bgcolor=#E6E6FA>1bit</th>
    <th bgcolor=#E6E6FA>2bit</th>
  </tr>
  <tr align="center">
    <td colspan="4" bgcolor=#E6E6FA>54bit</td>
    <td bgcolor=#E6E6FA>2bit</td>
    <td bgcolor=#E6E6FA>是否偏向锁</td>
    <td bgcolor=#E6E6FA>锁标志位</td>
  </tr>
  <tr align="center">
    <td>无锁状态</td>
    <td colspan="2">unused</td>
    <td colspan="3">对象的hash code</td>
    <td>unused</td>
    <td>分代年龄</td>
    <td>0</td>
    <td>01</td>
  </tr>
  <tr align="center">
    <td>轻量级锁</td>
    <td  colspan="8">指向栈中锁记录的指针</td>
    <td>00</td>
  </tr>
    <tr align="center">
    <td>重量级锁</td>
    <td  colspan="8">指向互斥量(重量级锁)的指针</td>
    <td>10</td>
  </tr>
    <tr align="center">
    <td>GC标志</td>
    <td  colspan="8">unused</td>
    <td>11</td>
  </tr>
    <tr align="center">
    <td>偏向锁</td>
    <td colspan="4" >线程ID</td>
    <td>epoch</td>
    <td>unused</td>
    <td>分代年龄</td>
    <td>1</td>
    <td>01</td>
  </tr>
</table>



<p>2、默认值不总是15，在PS 垃圾收集器中的默认值是15，而在<code>CMS</code>垃圾回收器中是6，参考官方文档中：</p>
<blockquote>
<p><code>-XX:MaxTenuringThreshold</code>=<em>threshold</em>Sets the maximum tenuring threshold for use in adaptive GC sizing. <strong>The largest value is 15</strong>. <strong>The default value is 15 for the parallel (throughput) collector,</strong> and <strong>6 for the CMS collector.</strong></p>
</blockquote>
<p>可以写个简单的代码，查看一下<code>MaxTenuringThreshold</code>的值，查看方式可以使用如下方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jinfo -flag MaxTenuringThreshold <span class="variable">$&#123;pid&#125;</span> <span class="comment"># pid为java进程id</span></span></span><br></pre></td></tr></table></figure>
<p><strong>这里需要注意，<code>CMS</code>的默认值是6，在一些情况下会导致这个阈值不再是6。</strong></p>
<p>1、显示设置<code>MaxTenuringThreshold</code> 肯定算啦。</p>
<p>2、还有一种情况就是显示设置<code>SurvivorRatio</code>的值之后，那么最大晋升年龄就会变成15。</p>
<p>感兴趣的同学可以自己写个简单的demo测试一下，指定使用<code>CMS</code>垃圾收集器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC </span><br><span class="line">-XX:SurvivorRatio=8  # 设置这个值和不设置这个值分别进行测试</span><br><span class="line">-XX:+PrintGCDetails </span><br><span class="line">-XX:+PrintTenuringDistribution</span><br></pre></td></tr></table></figure>
<p>并且可以在GC 日志中查看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew</span><br><span class="line">Desired survivor size 2621440 bytes, new threshold 1 (max 15) &#x2F;&#x2F; &lt;-- 看这，出现了new threshold 1 (max 15)</span><br><span class="line">- age   1:    4907592 bytes,    4907592 total</span><br><span class="line">: 28288K-&gt;4818K(35840K), 0.0038409 secs] 28288K-&gt;4818K(46080K), 0.0051496 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br></pre></td></tr></table></figure>
<p>可以在<code>openjdk</code>的源码中得到验证。在<code>arguments.cpp</code>中找到了<code>CMS</code>和<code>ParNew</code>设置参数的函数：<code>Arguments::set_cms_and_parnew_gc_flags()</code>，在函数中可以看到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now make adjustments for CMS</span></span><br><span class="line">intx   tenuring_default = (intx)<span class="number">6</span>;</span><br><span class="line"><span class="keyword">size_t</span> young_gen_per_worker = CMSYoungGenPerWorker;</span><br></pre></td></tr></table></figure>
<p>可以明确的看到，默认值就是6，但是再往下翻就可以看到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unless explicitly requested otherwise, definitely</span></span><br><span class="line"><span class="comment">// promote all objects surviving &quot;tenuring_default&quot; scavenges.</span></span><br><span class="line"><span class="keyword">if</span> (FLAG_IS_DEFAULT(MaxTenuringThreshold) &amp;&amp;</span><br><span class="line">FLAG_IS_DEFAULT(SurvivorRatio)) &#123;</span><br><span class="line">	FLAG_SET_ERGO(uintx, MaxTenuringThreshold, tenuring_default);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方文档中说的<code>CMS </code>垃圾收集器的<code>MaxTenuringThreshold</code>为6，是在不手动设置参数<code>MaxTenuringThreshold</code> 和 <code>SurvivorRatio</code>的情况下默认是6，但是显式的设置了这两者中的任意一者，那么最大晋升年龄就会变成你手动设置的值或者是15。</p>
<hr>
<h3 id="大对象直接进入老年代。"><a href="#大对象直接进入老年代。" class="headerlink" title="大对象直接进入老年代。"></a>大对象直接进入老年代。</h3><p>大对象是指需要大量连续内存空间的对象，《深入理解Java虚拟机》中提到大对象主要指字符串和数组，虚拟机提供了一个<code>-XX:PretenureSizeThreshold</code>参数，大于这个值的参数直接在老年代分配。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存复制（新生代采用的是复制算法）。</p>
<p>这里有两个点想说：</p>
<p>1、<code>PretenureSizeThreshold</code>默认值是0，也就是说如果不进行设置，任何对象都会优先在Eden区进行分配。</p>
<p>2、只有<code>Serial</code>和<code>ParNew</code>这两个年轻代的垃圾回收器支持<code>PretenureSizeThreshold</code>这个参数。<code>Parallel Scavenge</code>垃圾回收器是不认识这个参数的，这并不代表中在<code>Parallel Scavenge</code>中不存在大对象直接进入老年代的情况，只是换了一种实现方式而已。</p>
<p>接下来举个简单的例子，写个简单的测试代码来进行验证。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/sxfsuma/cloudImg//data/img/%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90.jpg" alt="举个栗子"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigObjectToOldGenTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] a1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">        <span class="keyword">byte</span>[] a2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">        <span class="keyword">byte</span>[] a3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">        <span class="keyword">byte</span>[] a4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1M];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>如果没有特殊说明，以下测试都在上诉代码下进行，设置不同的启动参数。</em></p>
<h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a><code>Parallel Scavenge</code></h4><p>在<code>JDK1.8</code>下使用默认的PS 垃圾收集器不设置<code>PretenureSizeThreshold</code>，设置<code>VM</code>参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">年轻代和老年代各占10M，年轻代中eden,from,to比例为8:1:1</span></span><br><span class="line">-Xms20M </span><br><span class="line">-Xmx20M </span><br><span class="line">-Xmn10M </span><br><span class="line">-XX:SurvivorRatio=8 </span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>
<p>查看运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 6348K-&gt;767K(9216K)] 6348K-&gt;4863K(19456K), 0.0044074 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 7316K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 79% used [0x00000000ff600000,0x00000000ffc656e0,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 74% used [0x00000000ffe00000,0x00000000ffebfcb0,0x00000000fff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 10240K, used 4096K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff000020,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3072K, capacity 4556K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 324K, capacity 392K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>可以看到最终老年代被占用了40%，就好像是a4对象直接在老年代进行了分配。并且在这之前进行了一次Young GC。</p>
<p>跟踪了一下<code>Parallel Scavenge</code>的具体实现，发现在<code>parallelScavengeHeap.cpp</code>的<code>ParallelScavengeHeap::mem_allocate</code>方法（<code>ParallelScavenge</code>的内存分配方法）中如果对象一开始在年轻代分配失败了，首先会对一些情况做判断，满足条件的就会分配在老年代，实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If certain conditions hold, try allocating from the old gen.</span></span><br><span class="line">result = mem_allocate_old_gen(size);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看<code>mem_allocate_old_gen</code>方法的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HeapWord* <span class="title">ParallelScavengeHeap::mem_allocate_old_gen</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!should_alloc_in_eden(size) || GC_locker::is_active_and_needs_gc()) &#123;</span><br><span class="line">    <span class="comment">// Size is too big for eden, or gc is locked out.</span></span><br><span class="line">    <span class="keyword">return</span> old_gen()-&gt;allocate(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a &quot;death march&quot; is in progress, allocate from the old gen a limited</span></span><br><span class="line">  <span class="comment">// number of times before doing a GC.</span></span><br><span class="line">  <span class="keyword">if</span> (_death_march_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_death_march_count &lt; <span class="number">64</span>) &#123;</span><br><span class="line">      ++_death_march_count;</span><br><span class="line">      <span class="keyword">return</span> old_gen()-&gt;allocate(size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _death_march_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>should_alloc_in_eden</code>方法就是判断是不是应该分配在Eden的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ParallelScavengeHeap::should_alloc_in_eden</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> eden_size = young_gen()-&gt;eden_space()-&gt;capacity_in_words();</span><br><span class="line">	<span class="keyword">return</span> size &lt; eden_size / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上面的代码，可以知道，<code>Parallel Scavenge</code>在进行对象分配时，<strong>如果对象的大小 &gt;= Eden区的一半，并不会经过空间分配担保机制，会直接将对象放入老年代中</strong>，这也就解释了上面GC日志的内容：<code>a1，a2，a3</code>，还在年轻代中，<code>a4</code>对象被直接分配到了老年代中。</p>
<p>其实也可以在逻辑上认为在PS垃圾回收器中的<code>PretenureSizeThreshold</code>的大小为eden区的一半大小，超过这个大小，就会在直接在老年代中进分配。</p>
<p>那如果将<code>a4</code>的大小设置成小于4M呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigObjectPSTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] a1,a2,a3,a4;</span><br><span class="line">		a1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1M];</span><br><span class="line">		a2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1M];</span><br><span class="line">		a3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1M];</span><br><span class="line">		<span class="comment">// a4修改为3M</span></span><br><span class="line">		a4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>*_1M];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 8144K-&gt;744K(9216K)] 8144K-&gt;6896K(19456K), 0.0041046 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 744K-&gt;0K(9216K)] [ParOldGen: 6152K-&gt;6747K(10240K)] 6896K-&gt;6747K(19456K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0057705 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 3237K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 39% used [0x00000000ff600000,0x00000000ff9297c8,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 10240K, used 6747K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 65% used [0x00000000fec00000,0x00000000ff296c40,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3235K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>a4</code>对象设置为3M之后，小于了Eden区的一半，此时就触发了<strong>空间分配担保</strong>机制，将原有的<code>a1, a2, a3</code>对象移动到了老年代，此时Eden区就清空了，可以容纳下<code>a4</code>对象。</p>
<p><strong>但是此时有新一个新的问题需要注意，除了Young GC之外，触发了一次Full GC，在后面进行分析。</strong></p>
<h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a><code>Serial</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC </span><br><span class="line">-Xms20M </span><br><span class="line">-Xmx20M </span><br><span class="line">-Xmn10M </span><br><span class="line">-XX:SurvivorRatio=8 </span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 8145K-&gt;628K(9216K), 0.0048082 secs] 8145K-&gt;6772K(19456K), 0.0048630 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4806K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  61% used [0x00000000ff500000, 0x00000000ff59d0c0, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3235K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>在分配a4时发现Eden内存不足发生了一次<code>Young GC</code>，但是a1，a2，a3都是存活对象，而且a1+a2+a3 = 6M &gt;Survivor（1M），此时就会触发<strong>分配担保</strong>机制将a1，a2，a3提前转移到老年代中，a4还是被分配到了Eden区。</p>
<p>设置<code>-XX:PretenureSizeThreshold=3145728</code>（3M）</p>
<p>设置启动参数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC </span><br><span class="line">-Xms20M </span><br><span class="line">-Xmx20M </span><br><span class="line">-Xmn10M </span><br><span class="line">-XX:SurvivorRatio&#x3D;8 </span><br><span class="line">-XX:+PrintGCDetails </span><br><span class="line">-XX:PretenureSizeThreshold&#x3D;3145728</span><br></pre></td></tr></table></figure>
<p>查看输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 8192K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K, 100% used [0x00000000fec00000, 0x00000000ff400000, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>此时a4直接在老年代中进行了分配，并未触发Young GC。</p>
<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a><code>ParNew</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio&#x3D;8 -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>
<p>不设置阈值时，输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: 7813K-&gt;615K(9216K), 0.0048937 secs] 7813K-&gt;6759K(19456K), 0.0049503 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 4876K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff029150, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  60% used [0x00000000ff500000, 0x00000000ff599ec0, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3104K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 336K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release</span><br></pre></td></tr></table></figure>
<p>设置阈值为3M</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio&#x3D;8 -XX:+PrintGCDetails -XX:PretenureSizeThreshold&#x3D;3145728</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 8192K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K, 100% used [0x00000000fec00000, 0x00000000ff400000, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release</span><br></pre></td></tr></table></figure>
<p>可以看到除了多一个提示之外，其他表现与<code>Serial</code>一致，不在赘述。</p>
<hr>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><blockquote>
<p> 在发生Minor GC之前，虚拟机会先检查老年代中<strong>最大的可用的连续空间是否大于新生代中所有对象总空间</strong>，如果这个条件成立，那么Minor GC可以确保是安全的，如果不成立，则虚拟机会查看<code>HandlePromotionFaiure</code>设置值是否允许担保失败。如果允许（值为true），那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果<strong>大于</strong>，将尝试进行一次Minor GC，尽管这次GC是有风险的；如果<strong>小于</strong>，或者<code>HandlePromotionFaiure</code>设置不允许冒险（值为false），那么这时就要改为进行一次Full GC。 </p>
</blockquote>
<blockquote>
<p>所谓冒险：也就是说当用来轮转的to区无法承受新生代中所存活的对象内存时，需要老年代进行分配担保，（也就是说，在新生代中进行垃圾回收时候，需要将 Eden区域和from区域中存活的对象拷贝到to区域中去，但是如果to区域的大小不足以放下这些存活的对象，那么就需要将这些对象放入到老年代中去，需要老年代中有足够的空间）把to无法容纳的对象直接进入老年代中，前提是老年代中有足够的空间。</p>
</blockquote>
<p><strong>在JDK1.6 Update 24之后，<code>HandlePromotionFaiure</code>参数不会再影响到虚拟机的空间分配担保策略，规则修改为：只要老年代的连续空间大于（新生代对象总大小或者历次晋升的平均大小），进行Minor GC，否则进行Full GC。</strong></p>
<p>在大对象进入老年代的实验中，其实已经看到空间分配担保的作用，不再单独做实验验证。</p>
<p>但是在上面遗留了一个问题，就是在使用 <code>Parallel Scavenge</code> 垃圾收集器时，当a4对象设置为3M时，小于Eden区的一半，触发空间分配担保机制，将a1, a2, a3对象移到到老年代中，在Eden区进行a4的分配，此时的Eden区是足够的，为什么紧接着还发生了一次Full GC呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Ergonomics) [PSYoungGen: 744K-&gt;0K(9216K)] [ParOldGen: 6152K-&gt;6747K(10240K)] 6896K-&gt;6747K(19456K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0057705 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br></pre></td></tr></table></figure>
<p>为什么会出现这样的情况呢？</p>
<p>首先需要明确一点，造成GC的原因有很多种。不单单只有空间分配失败（Allocation Failure）,可以在<code>gcCause.cpp</code>文件中查看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GCCause::to_string</span><span class="params">(GCCause::Cause cause)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (cause) &#123;</span><br><span class="line">    <span class="keyword">case</span> _java_lang_system_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;System.gc()&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _full_gc_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;FullGCAlot&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _scavenge_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ScavengeAlot&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_profiler:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Allocation Profiler&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _jvmti_force_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;JvmtiEnv ForceGarbageCollection&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _gc_locker:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;GCLocker Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_inspection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Heap Inspection Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_dump:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Heap Dump Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_young_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;WhiteBox Initiated Young GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_conc_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;WhiteBox Initiated Concurrent Mark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_inc:</span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Update Allocation Context Stats&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _no_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;No GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_failure:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Allocation Failure&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _tenured_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Tenured Generation Full&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_threshold:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Metadata GC Threshold&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Generation Full&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_initial_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Initial Mark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_final_remark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Final Remark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_concurrent_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Concurrent Mark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_expanded_on_last_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Old Generation Expanded On Last Scavenge&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_too_full_to_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Old Generation Too Full To Scavenge&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _adaptive_size_policy:   <span class="comment">// 看这，后面会使用到。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Ergonomics&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_inc_collection_pause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;G1 Evacuation Pause&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_humongous_allocation:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;G1 Humongous Allocation&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_ditch_collection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Last ditch collection&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_gc_cause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ILLEGAL VALUE - last gc cause - ILLEGAL VALUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;unknown GCCause&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ShouldNotReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>根据GC日志，可以知道，造成本次Full GC的原因是<strong>Ergonomics</strong></p>
<p>跟踪<code>Parallel Scavenge</code> 垃圾回收器的垃圾回收策略的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PSScavenge::invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  assert(SafepointSynchronize::is_at_safepoint(), <span class="string">&quot;should be at safepoint&quot;</span>);</span><br><span class="line">  assert(Thread::current() == (Thread*)VMThread::vm_thread(), <span class="string">&quot;should be in vm thread&quot;</span>);</span><br><span class="line">  assert(!Universe::heap()-&gt;is_gc_active(), <span class="string">&quot;not reentrant&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ParallelScavengeHeap* <span class="keyword">const</span> heap = (ParallelScavengeHeap*)Universe::heap();</span><br><span class="line">  assert(heap-&gt;kind() == CollectedHeap::ParallelScavengeHeap, <span class="string">&quot;Sanity&quot;</span>);</span><br><span class="line"></span><br><span class="line">  PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();</span><br><span class="line">  IsGCActiveMark mark;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> scavenge_done = PSScavenge::invoke_no_policy();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> need_full_gc = !scavenge_done ||</span><br><span class="line">    policy-&gt;should_full_GC(heap-&gt;old_gen()-&gt;free_in_bytes());</span><br><span class="line">  <span class="keyword">bool</span> full_gc_done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UsePerfData) &#123;</span><br><span class="line">    PSGCAdaptivePolicyCounters* <span class="keyword">const</span> counters = heap-&gt;gc_policy_counters();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ffs_val = need_full_gc ? full_follows_scavenge : not_skipped;</span><br><span class="line">    counters-&gt;update_full_follows_scavenge(ffs_val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (need_full_gc) &#123;</span><br><span class="line">    <span class="function">GCCauseSetter <span class="title">gccs</span><span class="params">(heap, GCCause::_adaptive_size_policy)</span></span>;</span><br><span class="line">    CollectorPolicy* cp = heap-&gt;collector_policy();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> clear_all_softrefs = cp-&gt;should_clear_all_soft_refs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UseParallelOldGC) &#123;</span><br><span class="line">      full_gc_done = PSParallelCompact::invoke_no_policy(clear_all_softrefs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      full_gc_done = PSMarkSweep::invoke_no_policy(clear_all_softrefs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> full_gc_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中对于Full GC来说比较核心的代码是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (need_full_gc) &#123;</span><br><span class="line">  <span class="function">GCCauseSetter <span class="title">gccs</span><span class="params">(heap, GCCause::_adaptive_size_policy)</span></span>;</span><br><span class="line">  CollectorPolicy* cp = heap-&gt;collector_policy();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> clear_all_softrefs = cp-&gt;should_clear_all_soft_refs();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UseParallelOldGC) &#123;</span><br><span class="line">    full_gc_done = PSParallelCompact::invoke_no_policy(clear_all_softrefs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    full_gc_done = PSMarkSweep::invoke_no_policy(clear_all_softrefs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要通过一个<code>need_full_gc</code>变量来确认是否需要进行Full GC。根据gcCause也知道<code>GCCause::_adaptive_size_policy</code>就是Ergonomics</p>
<p>而<code>need_full_gc</code>是怎么确定的呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> scavenge_done = PSScavenge::invoke_no_policy();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> need_full_gc = !scavenge_done || policy-&gt;should_full_GC(heap-&gt;old_gen()-&gt;free_in_bytes());</span><br></pre></td></tr></table></figure>
<p>首先看一下<code>invoke_no_policy</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This method contains no policy. You should probably</span></span><br><span class="line"><span class="comment">// be calling invoke() instead.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PSScavenge::invoke_no_policy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前面省略</span></span><br><span class="line">  ParallelScavengeHeap* heap = (ParallelScavengeHeap*)Universe::heap();</span><br><span class="line">    <span class="comment">// 获取GC原因</span></span><br><span class="line">  GCCause::Cause gc_cause = heap-&gt;gc_cause();</span><br><span class="line">  assert(heap-&gt;kind() == CollectedHeap::ParallelScavengeHeap, <span class="string">&quot;Sanity&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for potential problems.</span></span><br><span class="line">  <span class="comment">//在youngc之前进行检查，看看是否要直接触发fullgc</span></span><br><span class="line">  <span class="keyword">if</span> (!should_attempt_scavenge()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//.....	   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>should_attempt_scavenge</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否要尝试回收，当返回false-触发fullgc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PSScavenge::should_attempt_scavenge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ParallelScavengeHeap* heap = (ParallelScavengeHeap*)Universe::heap();</span><br><span class="line">  assert(heap-&gt;kind() == CollectedHeap::ParallelScavengeHeap, <span class="string">&quot;Sanity&quot;</span>);</span><br><span class="line">  PSGCAdaptivePolicyCounters* counters = heap-&gt;gc_policy_counters();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UsePerfData) &#123;</span><br><span class="line">    counters-&gt;update_scavenge_skipped(not_skipped);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PSYoungGen* young_gen = heap-&gt;young_gen();</span><br><span class="line">  PSOldGen* old_gen = heap-&gt;old_gen();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ScavengeWithObjectsInToSpace) &#123;</span><br><span class="line">    <span class="comment">// Do not attempt to promote unless to_space is empty</span></span><br><span class="line">      <span class="comment">//若toSpace不为空则直接返回false，触发fullgc</span></span><br><span class="line">    <span class="keyword">if</span> (!young_gen-&gt;to_space()-&gt;is_empty()) &#123;</span><br><span class="line">      _consecutive_skipped_scavenges++;</span><br><span class="line">      <span class="keyword">if</span> (UsePerfData) &#123;</span><br><span class="line">        counters-&gt;update_scavenge_skipped(to_space_not_empty);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test to see if the scavenge will likely fail.</span></span><br><span class="line">  PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A similar test is done in the policy&#x27;s should_full_GC().  If this is</span></span><br><span class="line">  <span class="comment">// changed, decide if that test should also be changed.</span></span><br><span class="line">  <span class="keyword">size_t</span> avg_promoted = (<span class="keyword">size_t</span>) policy-&gt;padded_average_promoted_in_bytes();</span><br><span class="line">    <span class="comment">//取最小值(之前YGC晋升到old的平均大小，新生代已使用大小)</span></span><br><span class="line">  <span class="keyword">size_t</span> promotion_estimate = MIN2(avg_promoted, young_gen-&gt;used_in_bytes());</span><br><span class="line">    <span class="comment">//若小于old的空闲空间，则表示无需full gc</span></span><br><span class="line">  <span class="keyword">bool</span> result = promotion_estimate &lt; old_gen-&gt;free_in_bytes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (PrintGCDetails &amp;&amp; Verbose) &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    _consecutive_skipped_scavenges = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _consecutive_skipped_scavenges++;</span><br><span class="line">    <span class="keyword">if</span> (UsePerfData) &#123;</span><br><span class="line">      counters-&gt;update_scavenge_skipped(promoted_too_large);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入<code>should_full_GC</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the remaining free space in the old generation is less that</span></span><br><span class="line"><span class="comment">// that expected to be needed by the next collection, do a full</span></span><br><span class="line"><span class="comment">// collection now.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PSAdaptiveSizePolicy::should_full_GC</span><span class="params">(<span class="keyword">size_t</span> old_free_in_bytes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A similar test is done in the scavenge&#x27;s should_attempt_scavenge().  If</span></span><br><span class="line">  <span class="comment">// this is changed, decide if that test should also be changed.</span></span><br><span class="line">  <span class="comment">// 如果晋升到老生代的平均大小大于老生代的剩余大小，则会返回true，认为需要一次full gc。</span></span><br><span class="line">  <span class="keyword">bool</span> result = padded_average_promoted_in_bytes() &gt; (<span class="keyword">float</span>) old_free_in_bytes;</span><br><span class="line">  <span class="keyword">if</span> (PrintGCDetails &amp;&amp; Verbose) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      gclog_or_tty-&gt;print(<span class="string">&quot;  full after scavenge: &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      gclog_or_tty-&gt;print(<span class="string">&quot;  no full after scavenge: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    gclog_or_tty-&gt;print_cr(<span class="string">&quot; average_promoted &quot;</span> SIZE_FORMAT</span><br><span class="line">      <span class="string">&quot; padded_average_promoted &quot;</span> SIZE_FORMAT</span><br><span class="line">      <span class="string">&quot; free in old gen &quot;</span> SIZE_FORMAT,</span><br><span class="line">      (<span class="keyword">size_t</span>) average_promoted_in_bytes(),</span><br><span class="line">      (<span class="keyword">size_t</span>) padded_average_promoted_in_bytes(),</span><br><span class="line">      old_free_in_bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>padded_average_promoted_in_bytes()</code>大于老生代剩余空间，那么就返回true，表示要触发一次Full GC。</p>
<p>那么padded_average_promoted_in_bytes()这个平均大小是怎么算出来的呢？我们去看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Padded average in bytes</span></span><br><span class="line">size_t padded_average_promoted_in_bytes() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (size_t)_avg_promoted-&gt;padded_average();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float padded_average() <span class="keyword">const</span>         &#123; <span class="keyword">return</span> _padded_avg; &#125;</span><br><span class="line"><span class="comment">// A weighted average that includes a deviation from the average,</span></span><br><span class="line"><span class="comment">// some multiple of which is added to the average.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This serves as our best estimate of an upper bound on a future</span></span><br><span class="line"><span class="comment">// unknown.</span></span><br><span class="line">class AdaptivePaddedAverage : public AdaptiveWeightedAverage &#123;</span><br><span class="line"> private:</span><br><span class="line">  float          _padded_avg;     <span class="comment">// The last computed padded average</span></span><br><span class="line">  float          _deviation;      <span class="comment">// Running deviation from the average</span></span><br><span class="line">  unsigned       _padding;        <span class="comment">// A multiple which, added to the average,</span></span><br><span class="line">                                  <span class="comment">// gives us an upper bound guess.</span></span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  <span class="keyword">void</span> <span class="function"><span class="title">set_padded_average</span>(<span class="params">float avg</span>)</span>  &#123; _padded_avg = avg;  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="function"><span class="title">set_deviation</span>(<span class="params">float dev</span>)</span>       &#123; _deviation  = dev;  &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  AdaptivePaddedAverage() :</span><br><span class="line">    AdaptiveWeightedAverage(<span class="number">0</span>),</span><br><span class="line">    _padded_avg(<span class="number">0.0</span>), _deviation(<span class="number">0.0</span>), <span class="function"><span class="title">_padding</span>(<span class="params"><span class="number">0</span></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  AdaptivePaddedAverage(unsigned weight, unsigned padding) :</span><br><span class="line">    AdaptiveWeightedAverage(weight),</span><br><span class="line">    _padded_avg(<span class="number">0.0</span>), _deviation(<span class="number">0.0</span>), <span class="function"><span class="title">_padding</span>(<span class="params">padding</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Placement support</span></span><br><span class="line">  <span class="keyword">void</span>* operator <span class="keyword">new</span>(size_t ignored, <span class="keyword">void</span>* p) <span class="keyword">throw</span>() &#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">  <span class="comment">// Allocator</span></span><br><span class="line">  <span class="keyword">void</span>* operator <span class="keyword">new</span>(size_t size) <span class="keyword">throw</span>() &#123; <span class="keyword">return</span> CHeapObj&lt;mtGC&gt;::operator <span class="keyword">new</span>(size); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessor</span></span><br><span class="line">  float padded_average() <span class="keyword">const</span>         &#123; <span class="keyword">return</span> _padded_avg; &#125;</span><br><span class="line">  float deviation()      <span class="keyword">const</span>         &#123; <span class="keyword">return</span> _deviation;  &#125;</span><br><span class="line">  unsigned padding()     <span class="keyword">const</span>         &#123; <span class="keyword">return</span> _padding;    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    AdaptiveWeightedAverage::clear();</span><br><span class="line">    _padded_avg = <span class="number">0</span>;</span><br><span class="line">    _deviation = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Override</span></span><br><span class="line">  <span class="keyword">void</span>  sample(float new_sample);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Printing</span></span><br><span class="line">  <span class="keyword">void</span> print_on(outputStream* st) <span class="keyword">const</span>;</span><br><span class="line">  <span class="keyword">void</span> print() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以从代码和注释中我们发现：<strong>加权平均值包括与平均值的偏差，其平均值加上其中的一些倍数。 这是对未来未知数的上限的最佳估计。</strong></p>
<p>也就是通过这样的算法，<strong>虚拟机估算出下次分配可能会发生无法分配的问题</strong>，于是<strong>提前预测到可能的问题，提前发生一次Full GC</strong>。</p>
<p>在JVM中的垃圾收集器中的Ergonomics就是负责自动的调解GC暂停时间和吞吐量之间的平衡，然后你的虚拟机性能更好的一种做法。对于注重吞吐量的收集器来说，在某个generation被过渡使用之前，GC Ergonomics就会启动一次GC。</p>
<h3 id="动态年龄判定"><a href="#动态年龄判定" class="headerlink" title="动态年龄判定"></a>动态年龄判定</h3><blockquote>
<p>为了更好的适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了<code>MaxTenuringThreshold</code>才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。       </p>
<p>来自《深入理解Java虚拟机》</p>
</blockquote>
<p>上面有一个误解，就是并不需要是<strong>相同的年龄</strong>的对象占用空间的大小大于Survivor空间的一半才会晋升。而是<strong>按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和<code>MaxTenuringThreshold</code>中更小的一个值，作为新的晋升年龄阈值。</strong></p>
<p>下面使用一个例子来实际分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] a1, a2, a3, a4;</span><br><span class="line">    <span class="comment">//a1 + a2大于survivor空间一半</span></span><br><span class="line">    a1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    a2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    a3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    a4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    a4 = <span class="keyword">null</span>;</span><br><span class="line">    a4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置启动参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC   # 因为使用PS收集器会满足大对象进入老年代的限制，所以使用Serial</span><br><span class="line">-Xms20M</span><br><span class="line">-Xmx20M</span><br><span class="line">-Xmn10M</span><br><span class="line">-XX:SurvivorRatio&#x3D;8</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;15</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size 524288 bytes, new threshold 1 (max 15)</span><br><span class="line">- age   1:    1048568 bytes,    1048568 total</span><br><span class="line">: 6609K-&gt;1023K(9216K), 0.0047654 secs] 6609K-&gt;5208K(19456K), 0.0048379 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size 524288 bytes, new threshold 15 (max 15)</span><br><span class="line">- age   1:        800 bytes,        800 total</span><br><span class="line">: 5204K-&gt;0K(9216K), 0.0013057 secs] 9388K-&gt;5209K(19456K), 0.0013293 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4234K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff022728, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400320, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 5208K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  50% used [0x00000000ff600000, 0x00000000ffb16350, 0x00000000ffb16400, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3204K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 345K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>根据启动参数可以知道，初始的内存分布如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/sxfsuma/cloudImg//data/img/%E5%88%9D%E5%A7%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" alt="初始内存分布"></p>
<p>所以a1，a2，a3都是可以正常分配的。在进行第一次a4对象内存分配时，M/4+M/4+4M&gt;4608k（这里的大于是因为对象内存分配时还需要加上对象头以及内存补白等空间），所以8M-4608k&lt;4096k(4M)；</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/sxfsuma/cloudImg//data/img/%E7%AC%AC%E4%B8%80%E6%AC%A1a4%E5%88%86%E9%85%8D.png" alt="第一次a4分配.png"></p>
<p>所以垃圾收集器进行一次Minor GC；</p>
<p>GC的具体情况为，首先会将a1,a2两个对象复制到幸存者区，此时需要注意：（M/4*2=M/2=512k，加上对象头等数据则当前幸存者区被占用的内存超过了512k，即超过了幸存者区内存的1/2，所以新的阈值为：threshold=1）a3将直接复制到老年代，因为幸存者区不够放下a3，所以触发空间分配担保机制，将a3直接复制到老年代中，此时Eden区可以容纳a4对象。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/sxfsuma/cloudImg//data/img/%E7%AC%AC%E4%B8%80%E6%AC%A1YoungGc.png" alt="第一YoungGC.png"></p>
<p>对应的GC日志为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size 524288 bytes, new threshold 1 (max 15)  &#x2F;&#x2F; 看这，新的阈值</span><br><span class="line">- age   1:    1048568 bytes,    1048568 total</span><br><span class="line">: 6609K-&gt;1023K(9216K), 0.0047654 secs] 6609K-&gt;5208K(19456K), 0.0048379 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br></pre></td></tr></table></figure>


<p>经过<code>a4 = null;</code>处理。第一次分配的对象就处于不可达的状态了，因为没有引用指向它了，这个对象就是可回收的对象了，然后再次执行</p>
<p><code>a4 = new byte[4 * _1MB];</code>时Eden区由于还存储着一个&gt;4M（包含对象头与内存补白）的对象，所以Eden区8M内存不足以再容易这个大于4M的对象内存，于是收集器又一次发起一个针对Young区的GC操作；</p>
<p>GC的过程如下：</p>
<p>经过<code>a4 = null;</code>所指向的对象会被垃圾回收掉。此时的Eden区就清空了，内存空间占用为0；新的对象可以在Eden区进行分配。</p>
<p>而from区(Survivor区)中由于上一次GC之后，进入老年代的年龄阈值被设置为了1，所以a1,a2对象的年龄已经达到了进入老年代 阈值，所以会被移到老年代中。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/sxfsuma/cloudImg//data/img/%E7%AC%AC%E4%BA%8C%E6%AC%A1YoungGc.png" alt="第二次YoungGc.png"></p>
<p>对应的GC日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size 524288 bytes, new threshold 15 (max 15) &#x2F;&#x2F; 看这，阈值恢复</span><br><span class="line">- age   1:        800 bytes,        800 total</span><br><span class="line">: 5204K-&gt;0K(9216K), 0.0013057 secs] 9388K-&gt;5209K(19456K), 0.0013293 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br></pre></td></tr></table></figure>
<p>最终堆内的情况为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4234K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff022728, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400320, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 5208K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  50% used [0x00000000ff600000, 0x00000000ffb16350, 0x00000000ffb16400, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3204K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 345K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>


<p><code>JVM</code>中还有另外一个参数：<code>-XX:TargetSurvivorRatio</code>，这是期望survivor区存活大小的参数，默认是50，即50%。而在<code>ageTable.cpp</code>的动态计算方法<code>ageTable::compute_tenuring_threshold</code>中则使用到了这个参数进行计算<code>desired_survivor_size</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">  uint age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">    total += sizes[age];</span><br><span class="line">    <span class="comment">// check if including objects of age &#x27;age&#x27; made us pass the desired</span></span><br><span class="line">    <span class="comment">// size, if so &#x27;age&#x27; is the new threshold</span></span><br><span class="line">    <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的说即默认情况下如果某一年龄值的超过了survivor的50%，此年龄值与<code>MaxTenuringThreshold</code>两者中更小的值将会成为新的晋升阈值。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解Java虚拟机》（第二版） 周志明</p>
<p><a target="_blank" rel="noopener" href="https://www.doudaxia.club/index.php/archives/135/">https://www.doudaxia.club/index.php/archives/135/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.doudaxia.club/index.php/archives/90/">https://www.doudaxia.club/index.php/archives/90/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.reins.altervista.org/java/gc1.4.2_faq.html">http://www.reins.altervista.org/java/gc1.4.2_faq.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24986539/article/details/107904163">https://blog.csdn.net/qq_24986539/article/details/107904163</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1082687">https://cloud.tencent.com/developer/article/1082687</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">mastersxf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sxfsuma.github.io/2021/01/17/java/jvm/%E5%AF%B9%E8%B1%A1%E8%80%81%E5%B9%B4%E4%BB%A3%E6%83%85%E5%86%B5%E6%B5%85%E6%9E%90/">https://sxfsuma.github.io/2021/01/17/java/jvm/%E5%AF%B9%E8%B1%A1%E8%80%81%E5%B9%B4%E4%BB%A3%E6%83%85%E5%86%B5%E6%B5%85%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sxfsuma.github.io" target="_blank">sxfsuma</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Jvm/">Jvm</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.JsDelivr.net/gh/sxfsuma/cloudImg//data/img路人女主-加藤惠.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2019/12/19/java/basic/Java-%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97/"><img class="next-cover" data-lazy-src="https://i.loli.net/2019/12/18/shECrwo3npJ75Gc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 对象大小计算</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%82"><span class="toc-number">1.</span> <span class="toc-text">长期存活对象进入老年代。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%82"><span class="toc-number">2.</span> <span class="toc-text">大对象直接进入老年代。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge"><span class="toc-number">2.1.</span> <span class="toc-text">Parallel Scavenge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial"><span class="toc-number">2.2.</span> <span class="toc-text">Serial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew"><span class="toc-number">2.3.</span> <span class="toc-text">ParNew</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">3.</span> <span class="toc-text">空间分配担保</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="toc-number">4.</span> <span class="toc-text">动态年龄判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By mastersxf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"></div></div></body></html>